<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>工作笔记：游戏开发 on 花落无声的站点</title>
    <link>/blog/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 工作笔记：游戏开发 on 花落无声的站点</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Wed, 02 Jun 2021 09:26:19 +0800</lastBuildDate><atom:link href="/blog/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>工作笔记：游戏开发：垃圾回收与大对象堆机制</title>
      <link>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6windows%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A0%86%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 02 Jun 2021 09:26:19 +0800</pubDate>
      
      <guid>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6windows%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A0%86%E6%9C%BA%E5%88%B6/</guid>
      <description>垃圾回收 相关概念和术语 Windows 内存 API VirtualAlloc/VirtualFree：Windows系统调用API，用于在当前进程的虚拟内存空间中操作一页内存。Windows编程可用，Windows平台上G</description>
    </item>
    
    <item>
      <title>工作笔记：游戏开发：CLOC工具的使用</title>
      <link>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/cloc%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 01 Jun 2021 15:31:28 +0800</pubDate>
      
      <guid>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/cloc%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>CLOC 仓库地址：https://github.com/AlDanial/cloc 用于代码行数的计算。输入的参数可以为文件、压缩包、目录、或者git的提交记录或者分支等等。 计算代码行数 例如有test.cpp</description>
    </item>
    
    <item>
      <title>工作笔记：游戏开发：三维变换矩阵</title>
      <link>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E4%B8%89%E7%BB%B4%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Wed, 26 May 2021 17:15:51 +0800</pubDate>
      
      <guid>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E4%B8%89%E7%BB%B4%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/</guid>
      <description>齐次坐标 $v = (x, y, z)$，增加额外的维度：$v = (x,y,z,w)$：当$w=0$时表示向量，$w=1$时表示点。 变换 Transform 对于点或向量$v$做变换，右乘变换矩阵$W$：$v&#39; = vT$。 恒等 Identity $$I = diag(1, 1, 1, 1)$$ 伸</description>
    </item>
    
    <item>
      <title>工作笔记：游戏开发：C# StructLayout属性</title>
      <link>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/csharp-structlayout%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Tue, 25 May 2021 17:23:01 +0800</pubDate>
      
      <guid>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/csharp-structlayout%E5%B1%9E%E6%80%A7/</guid>
      <description>结论 使用StructLayout(LayoutKind.Explicit)时，引用类型可以重叠放在一起，但必须始终保持8字节对齐，引用类型不可以与任何值类型在任意字节重叠。 小心嵌套的类型，嵌套类型中尽</description>
    </item>
    
    <item>
      <title>工作笔记：游戏开发：Unity脚本生命周期</title>
      <link>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Fri, 21 May 2021 17:38:34 +0800</pubDate>
      
      <guid>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>生命周期 按照以下顺序执行： 绑定 Reset：游戏对象绑定脚本时调用 初始化 Awake：脚本绑定的游戏对象被激活时执行，无论该脚本是否禁用 OnEnable：脚本启用时执行 Start：脚本启用时，在OnEna</description>
    </item>
    
    <item>
      <title>工作笔记：游戏开发：泛型中值类型使用注意、值类型的函数调用和装箱</title>
      <link>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B3%9B%E5%9E%8B%E4%B8%AD%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E8%A3%85%E7%AE%B1/</link>
      <pubDate>Fri, 21 May 2021 17:37:39 +0800</pubDate>
      
      <guid>/blog/p/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B3%9B%E5%9E%8B%E4%B8%AD%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E8%A3%85%E7%AE%B1/</guid>
      <description>结论总结 不要用Equals比较两个值类型。最好用自己写的operator==。 写struct时，应该手动改写ToString、GetHashCode等方法。 不使用值类型（包括Enum）作为Dictio</description>
    </item>
    
  </channel>
</rss>
